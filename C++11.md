1. [auto](#auto) (04.10.2023)
2. [decltype](#decltype) (04.10.2023)
3. [default functions](#default-functions) (04.10.2023)
4. [deleted functions](#deleted-functions) (04.10.2023)
5. [final specifier](#final-specifier) (04.10.2023)
6. [override specifier](#override-specifier) (05.10.2023)
7. [rvalue references](#rvalue-references)



### auto
`auto` - specifies that the type of the variable that is being declared will be automatically deducted from its initializer.

```c++
auto a = 3.14; // double
auto b = 1; // int
auto& c = b; // int&
auto d = { 0 }; // std::initializer_list<int>
auto&& e = 1; // int&&
auto&& f = b; // int&
auto g = new auto(123); // int*
const auto h = 1; // const int
auto i = 1, j = 2, k = 3; // int, int, int
auto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool
auto o; // error -- `o` requires initializer
```

Extremely useful for readability, especially for complicated types:

```c++
std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}, {"Charlie", 22}};
for (auto it = ages.begin(); it != ages.end(); ++it) {
    // 'it' is automatically deduced as std::map<std::string, int>::iterator
    // You can use 'it' without specifying its type explicitly
    std::cout << it->first << ": " << it->second << std::endl;
}
```

### decltype

`decltype` - keyword is used to deduce the type of an expression or a variable at compile time. It allows you to extract the type of an expression or variable without actually evaluating it. decltype is often used in scenarios where you want to declare a variable with the same type as another variable or expression, or when you want to obtain the type of an expression for template metaprogramming or function declarations.

```c++
int x = 42;
decltype(x) y; // y has the same type as x, which is int
```
```c++
int a = 5;
double b = 3.14;
decltype(a + b) result; // result has the type of the expression a + b, which is double
```
```c++
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
In the above example, the decltype(t + u) is used in the return type of the add function to ensure that the function returns the same type as the addition of its arguments.
```
```c++
std::vector<int> numbers;
decltype(numbers)::value_type num; // num has the same type as the elements in the vector (int)
```
```c++
struct MyStruct {
    int x;
};
MyStruct s;
decltype(s.x) value; // value has the same type as s.x, which is int
```
```c++
int a = 1; // `a` is declared as type `int`
decltype(a) b = a; // `decltype(a)` is `int`
const int& c = a; // `c` is declared as type `const int&`
decltype(c) d = a; // `decltype(c)` is `const int&`
decltype(123) e = 123; // `decltype(123)` is `int`
int&& f = 1; // `f` is declared as type `int&&`
decltype(f) g = 1; // `decltype(f) is `int&&`
decltype((a)) h = g; // `decltype((a))` is int&
```

### default functions

`default` -  explicit instruction to the compiler to generate special member function.
You can use the default keyword to define a default constructor for a class. This is especially useful when you want to provide a user-defined constructor for a class but still want the compiler to generate the default constructor. Without using the default keyword, the C++ compiler will automatically generate the copy constructor, copy assignment operator, move constructor, and move assignment operator for a class if they are not explicitly defined. Using the `default` keyword is not required for the generation of these functions; it's used primarily for clarity, control, and adherence to best practices.

```ç++
class MyClass {
public:
    // User-defined constructor
    MyClass(int value) : data(value) {}

    // Compiler-generated default constructor
    MyClass() = default;

private:
    int data;
};
```

### deleted functions

`delete` -  You can use the delete keyword to explicitly delete a function, preventing it from being called. This is useful when you want to prevent certain operations or overloads for a class.
A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects.

```ç++
class A {
  int x;

public:
  A(int x) : x{x} {};
  A(const A&) = delete;
  A& operator=(const A&) = delete;
};

A x {123};
A y = x; // error -- call to deleted copy constructor
y = x; // error -- operator= deleted
```

In C++, you can use the delete keyword with templates to selectively disable or delete template specializations for certain types. This is useful when you want to restrict the use of a template to specific types or prevent the instantiation of the template with certain argument types.

```ç++
template <typename T>
void process(T value) {
    // Some template logic
}

// Delete the template specialization for char* as an argument type
template <>
void process<char*>(char* value) = delete;

int main() {
    int x = 42;
    process(x);      // OK, process<int>(int) is available
    char* str = "Hello";
    process(str);    // Error: process<char*>(char*) is deleted
    return 0;
}
```

### final specifier

`final` - specifies that a virtual function cannot be overridden in a derived class, or that a class cannot be derived from.

```ç++
struct A {
  virtual void foo();
};

struct B : A {
  virtual void foo() final;
};

struct C : B {
  virtual void foo(); // error -- declaration of 'foo' overrides a 'final' function
};
```

### override specifier
`override` - Specifies that a virtual function overrides another virtual function. 
If the virtual function does not override a parent's virtual function, throws a compiler error.

```ç++
struct A {
  virtual void foo();
  void bar();
};

struct B : A {
  void foo() override; // correct -- B::foo overrides A::foo
  void bar() override; // error -- A::bar is not virtual
  void baz() override; // error -- B::baz does not override A::baz
};
```

### rvalue references











