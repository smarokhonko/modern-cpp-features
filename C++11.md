- [auto](#auto)
- [decltype](#decltype)
- [default](#default)
- [deleted functions](#delete functions)

### auto
`auto` - specifies that the type of the variable that is being declared will be automatically deducted from its initializer.

```c++
auto a = 3.14; // double
auto b = 1; // int
auto& c = b; // int&
auto d = { 0 }; // std::initializer_list<int>
auto&& e = 1; // int&&
auto&& f = b; // int&
auto g = new auto(123); // int*
const auto h = 1; // const int
auto i = 1, j = 2, k = 3; // int, int, int
auto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool
auto o; // error -- `o` requires initializer
```

Extremely useful for readability, especially for complicated types:

```c++
std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}, {"Charlie", 22}};
for (auto it = ages.begin(); it != ages.end(); ++it) {
    // 'it' is automatically deduced as std::map<std::string, int>::iterator
    // You can use 'it' without specifying its type explicitly
    std::cout << it->first << ": " << it->second << std::endl;
}
```

### decltype

`decltype` - keyword is used to deduce the type of an expression or a variable at compile time. It allows you to extract the type of an expression or variable without actually evaluating it. decltype is often used in scenarios where you want to declare a variable with the same type as another variable or expression, or when you want to obtain the type of an expression for template metaprogramming or function declarations.

```c++
int x = 42;
decltype(x) y; // y has the same type as x, which is int
```
```c++
int a = 5;
double b = 3.14;
decltype(a + b) result; // result has the type of the expression a + b, which is double
```
```c++
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
In the above example, the decltype(t + u) is used in the return type of the add function to ensure that the function returns the same type as the addition of its arguments.
```
```c++
std::vector<int> numbers;
decltype(numbers)::value_type num; // num has the same type as the elements in the vector (int)
```
```c++
struct MyStruct {
    int x;
};
MyStruct s;
decltype(s.x) value; // value has the same type as s.x, which is int
```
```c++
int a = 1; // `a` is declared as type `int`
decltype(a) b = a; // `decltype(a)` is `int`
const int& c = a; // `c` is declared as type `const int&`
decltype(c) d = a; // `decltype(c)` is `const int&`
decltype(123) e = 123; // `decltype(123)` is `int`
int&& f = 1; // `f` is declared as type `int&&`
decltype(f) g = 1; // `decltype(f) is `int&&`
decltype((a)) h = g; // `decltype((a))` is int&
```

### default

`default` -  explicit instruction to the compiler to generate special member function.
You can use the default keyword to define a default constructor for a class. This is especially useful when you want to provide a user-defined constructor for a class but still want the compiler to generate the default constructor. Without using the default keyword, the C++ compiler will automatically generate the copy constructor, copy assignment operator, move constructor, and move assignment operator for a class if they are not explicitly defined. Using the `default` keyword is not required for the generation of these functions; it's used primarily for clarity, control, and adherence to best practices.

```รง++
class MyClass {
public:
    // User-defined constructor
    MyClass(int value) : data(value) {}

    // Compiler-generated default constructor
    MyClass() = default;

private:
    int data;
};
```

### delete functions

`delete` -  You can use the delete keyword to explicitly delete a function, preventing it from being called. This is useful when you want to prevent certain operations or overloads for a class.







