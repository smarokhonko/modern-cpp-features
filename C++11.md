1. [auto](#auto) (04.10.2023)
2. [decltype](#decltype) (04.10.2023)
3. [default functions](#default-functions) (04.10.2023)
4. [deleted functions](#deleted-functions) (04.10.2023)
5. [final specifier](#final-specifier) (04.10.2023)
6. [override specifier](#override-specifier) (05.10.2023)
7. [rvalue references](#rvalue-references)
8. [Move semantics](#Move-semantics)
9. [move constructors](#move-constructors)



### auto
`auto` - specifies that the type of the variable that is being declared will be automatically deducted from its initializer.

```c++
auto a = 3.14; // double
auto b = 1; // int
auto& c = b; // int&
auto d = { 0 }; // std::initializer_list<int>
auto&& e = 1; // int&&
auto&& f = b; // int&
auto g = new auto(123); // int*
const auto h = 1; // const int
auto i = 1, j = 2, k = 3; // int, int, int
auto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool
auto o; // error -- `o` requires initializer
```

Extremely useful for readability, especially for complicated types:

```c++
std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}, {"Charlie", 22}};
for (auto it = ages.begin(); it != ages.end(); ++it) {
    // 'it' is automatically deduced as std::map<std::string, int>::iterator
    // You can use 'it' without specifying its type explicitly
    std::cout << it->first << ": " << it->second << std::endl;
}
```

### decltype

`decltype` - keyword is used to deduce the type of an expression or a variable at compile time. It allows you to extract the type of an expression or variable without actually evaluating it. decltype is often used in scenarios where you want to declare a variable with the same type as another variable or expression, or when you want to obtain the type of an expression for template metaprogramming or function declarations.

```c++
int x = 42;
decltype(x) y; // y has the same type as x, which is int
```
```c++
int a = 5;
double b = 3.14;
decltype(a + b) result; // result has the type of the expression a + b, which is double
```
```c++
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
In the above example, the decltype(t + u) is used in the return type of the add function to ensure that the function returns the same type as the addition of its arguments.
```
```c++
std::vector<int> numbers;
decltype(numbers)::value_type num; // num has the same type as the elements in the vector (int)
```
```c++
struct MyStruct {
    int x;
};
MyStruct s;
decltype(s.x) value; // value has the same type as s.x, which is int
```
```c++
int a = 1; // `a` is declared as type `int`
decltype(a) b = a; // `decltype(a)` is `int`
const int& c = a; // `c` is declared as type `const int&`
decltype(c) d = a; // `decltype(c)` is `const int&`
decltype(123) e = 123; // `decltype(123)` is `int`
int&& f = 1; // `f` is declared as type `int&&`
decltype(f) g = 1; // `decltype(f) is `int&&`
decltype((a)) h = g; // `decltype((a))` is int&
```

### default functions

`default` -  explicit instruction to the compiler to generate special member function.
You can use the default keyword to define a default constructor for a class. This is especially useful when you want to provide a user-defined constructor for a class but still want the compiler to generate the default constructor. Without using the default keyword, the C++ compiler will automatically generate the copy constructor, copy assignment operator, move constructor, and move assignment operator for a class if they are not explicitly defined. Using the `default` keyword is not required for the generation of these functions; it's used primarily for clarity, control, and adherence to best practices.

```ç++
class MyClass {
public:
    // User-defined constructor
    MyClass(int value) : data(value) {}

    // Compiler-generated default constructor
    MyClass() = default;

private:
    int data;
};
```

### deleted functions

`delete` -  You can use the delete keyword to explicitly delete a function, preventing it from being called. This is useful when you want to prevent certain operations or overloads for a class.
A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects.

```ç++
class A {
  int x;

public:
  A(int x) : x{x} {};
  A(const A&) = delete;
  A& operator=(const A&) = delete;
};

A x {123};
A y = x; // error -- call to deleted copy constructor
y = x; // error -- operator= deleted
```

In C++, you can use the delete keyword with templates to selectively disable or delete template specializations for certain types. This is useful when you want to restrict the use of a template to specific types or prevent the instantiation of the template with certain argument types.

```ç++
template <typename T>
void process(T value) {
    // Some template logic
}

// Delete the template specialization for char* as an argument type
template <>
void process<char*>(char* value) = delete;

int main() {
    int x = 42;
    process(x);      // OK, process<int>(int) is available
    char* str = "Hello";
    process(str);    // Error: process<char*>(char*) is deleted
    return 0;
}
```

### final specifier

`final` - specifies that a virtual function cannot be overridden in a derived class, or that a class cannot be derived from.

```ç++
struct A {
  virtual void foo();
};

struct B : A {
  virtual void foo() final;
};

struct C : B {
  virtual void foo(); // error -- declaration of 'foo' overrides a 'final' function
};
```

### override specifier
`override` - Specifies that a virtual function overrides another virtual function. 
If the virtual function does not override a parent's virtual function, throws a compiler error.

```ç++
struct A {
  virtual void foo();
  void bar();
};

struct B : A {
  void foo() override; // correct -- B::foo overrides A::foo
  void bar() override; // error -- A::bar is not virtual
  void baz() override; // error -- B::baz does not override A::baz
};
```

### rvalue references

An rvalue (pronounced “arr-value”, short for “right value”, and sometimes written as r-value) is an expression that is not an lvalue. Commonly seen rvalues include literals (except C-style string literals, which are lvalues) and the return value of functions and operators that return by value. Rvalues aren’t identifiable (meaning they have to be used immediately), and only exist within the scope of the expression in which they are used.

```ç++
int return5()
{
    return 5;
}

int main()
{
    int x{ 5 }; // 5 is an rvalue expression
    const double d{ 1.2 }; // 1.2 is an rvalue expression

    int y { x }; // x is a modifiable lvalue expression
    const double e { d }; // d is a non-modifiable lvalue expression
    int z { return5() }; // return5() is an rvalue expression (since the result is returned by value)

    int w { x + 1 }; // x + 1 is an rvalue expression
    int q { static_cast<int>(d) }; // the result of static casting d to an int is an rvalue expression

    return 0;
}
```

If you’re not sure whether an expression is an lvalue or rvalue, try taking its address using operator&, which requires its operand to be an lvalue. If &(expression); compiles, expression must be an lvalue:

```ç++
int foo()
{
    return 5;
}

int main()
{
    int x { 5 };
    &x; // compiles: x is an lvalue expression
    &5; // doesn't compile: 5 is an rvalue expression
    &foo(); // doesn't compile: foo() is an rvalue expression
}
```
```ç++
int x = 0; // `x` is an lvalue of type `int`
int& xl = x; // `xl` is an lvalue of type `int&`
int&& xr = x; // compiler error -- `x` is an lvalue
int&& xr2 = 0; // `xr2` is an lvalue of type `int&&` -- binds to the rvalue temporary, `0`

void f(int& x) {}
void f(int&& x) {}

f(x);  // calls f(int&)
f(xl); // calls f(int&)
f(3);  // calls f(int&&)
f(std::move(x)); // calls f(int&&)

f(xr2);           // calls f(int&)
f(std::move(xr2)); // calls f(int&& x)
```

### Move semantics

Moving an object means to transfer ownership of some resource it manages to another object.

The first benefit of move semantics is performance optimization. When an object is about to reach the end of its lifetime, either because it's a temporary or by explicitly calling std::move, a move is often a cheaper way to transfer resources. For example, moving a std::vector is just copying some pointers and internal state over to the new vector -- copying would involve having to copy every single contained element in the vector, which is expensive and unnecessary if the old vector will soon be destroyed.

Moves also make it possible for non-copyable types such as std::unique_ptrs (smart pointers) to guarantee at the language level that there is only ever one instance of a resource being managed at a time, while being able to transfer an instance between scopes.

`std::move` is a utility function provided by the C++ Standard Library that allows you to cast an lvalue (an object with a persistent identity) into an rvalue reference. This casting operation is crucial for enabling move semantics in C++.

The primary purpose of std::move is to indicate to the compiler that you are willing to transfer ownership or enable move operations on an object. It does not actually move or modify the object itself; instead, it changes the way the object is treated when passed to functions or assigned to other variables.

### move constructors

A move constructor is a special member function in C++ that is used to move the resources (e.g., memory, ownership) of one object into another object efficiently. Move constructors are typically defined for user-defined classes and are an integral part of C++'s move semantics.

The move constructor is called when you create a new object by moving from an existing object or when you return an object by value from a function. It is invoked when you use the std::move function to cast an object into an rvalue reference.

Copy constructor copy everything from other object like a shallow copy and reset data within other object.

```ç++
#include <iostream>
#include <vector>
using namespace std;

class A{
  int *ptr;
public:
  A(){
    // Default constructor
    cout << "Calling Default constructor\n";
    ptr = new int ;
  }

  A( const A & obj){
    // Copy Constructor
    // copy of object is created
    this->ptr = new int;
    // Deep copying
    cout << "Calling Copy constructor\n";
  }

  A ( A && obj){
    // Move constructor
    // It will simply shift the resources,
    // without creating a copy.
     cout << "Calling Move constructor\n";
    this->ptr = obj.ptr;
    obj.ptr = NULL;
  }

  ~A(){
    // Destructor
    cout << "Calling Destructor\n";
    delete ptr;
  }

};

int main() {

  vector <A> vec;
  vec.push_back(A());

  return 0;

}
```

